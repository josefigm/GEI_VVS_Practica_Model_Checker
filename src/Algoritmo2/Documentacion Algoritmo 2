Autor: José Antonio Figueiras Martínez



*********************************************************
*                                                       *
*                       Algoritmo 2                     *
*                                                       *                                                
*********************************************************

Se realiza la ejecución del algoritmo 2, siendo N (número de filósofos) igual
a 5 con el comando spin algoritmo2.pml.


**********************************DEADLOCK*************************************

Aun que se indica que no hay interbloqueos, se realiza una búsqueda de interbloqueos ejecutando
el comando spin -search algoritmo2.pml. 

Ni con la profundidad por defecto (10000 pasos) ni con la máxima soportada por la CPU
se encuentran errores. (se probó con -m1000000)

*********************************FIN_DEADLOCK**********************************


*******************************MUTUAL_EXCLUSION********************************


Al igual que con el algoritmo 1, se usa una fórmula LTL de seguridad. La 
fórmula LTL de seguridad sería la misma: []!(P@cs && Q@cs), en donde
philosopher(0) y philosopher(1) son filósofos y cs es una etiqueta que
referencia a la linea que nos interesa comprobar.

Spin vuelve a necesitar una never claim, es decir, una condición que especifique un comportamiento 
imposible.

Al negar nuestra fórmula de seguridad nos queda lo siguiente:

- ![] equivale a <>
- !!(P@cs && Q@cs) equivale a (P@cs && Q@cs)

El resultado es igual a: <>(P@cs && Q@cs).

Se lanza el comando spin -a -f '<>(philosopher[0]@cs && philosopher[1]@cs)' -m70000 algoritmo2.pml
gcc -o pan -DSAFETY pan.c
./pan -E (-E para evitar ver errores relacionados con deadlock)

Al ejecutar pan, se observa que la condicion LTL se viola y que por tanto existe un estado
dentro de arbol que genera spin en donde philosopher[0] y philosopher[1] están ejecutando 
la linea etiquetada con cs. Ademas, genera el fichero de trail, 
en donde se podrá ver con detalle el contraejemplo:

Para verlo, basta con ejecutar spin -t -p algoritmo2.pml

Al final de la simulación guiada, se imprime por consola lo siguiente:

9999:   proc  4 (philosopher:1) algoritmo2.pml:17 (state 3)
9999:   proc  3 (philosopher:1) algoritmo2.pml:17 (state 3)
9999:   proc  2 (philosopher:1) algoritmo2.pml:15 (state 4)
9999:   proc  1 (philosopher:1) algoritmo2.pml:41 (state 8)
9999:   proc  0 (philosopher:1) algoritmo2.pml:41 (state 8)

En el paso 9999 el fichero trail muestra como efectivamente el philosopher[0](proc 0)
y el philosopher[1](proc 1) están ejecutando la linea 41 del algoritmo2, que se corres-
ponde con la linea etiquetada con cs. Por tanto, se incumple la exclusión mutua.


***************************FIN_MUTUAL_EXCLUSION********************************

***************************ABSENSE_OF_STARVATION********************************



***********************FIN_ABSENSE_OF_STARVATION********************************
